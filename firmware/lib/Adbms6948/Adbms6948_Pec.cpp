/*!
******************************************************************************
Copyright (c) 2022 Analog Devices, Inc. All Rights Reserved.
This software is proprietary & confidential to Analog Devices, Inc. and its
licensors. By using this software you agree to the terms of the associated
Analog Devices License Agreement.
******************************************************************************
* @file   : Adbms6948_Pec.cpp
* @brief  : Adbms6948 PEC calculation file
* @version: $Revision: 517 $
* @date   : $Date: 2020-10-13 11:33:31 +0530 (Tue, 13 Oct 2020) $
* Developed by: BMS Applications Team, Bangalore, India
*****************************************************************************/

/*! \addtogroup Adbms6948_Pec
* @{
*/
/*============= I N C L U D E S =============*/
#include "Adbms6948_Pec.h"
/*============= D A T A =============*/
/* Const 16 section start */
ADBMS6948_DRV_CONST_DATA_16_START

/* Pre-computed CRC15 Table */
static const int Adbms6948_Crc15Table[256] = {0x0u,0xc599u, 0xceabu, 0xb32u, 0xd8cfu, 0x1d56u, 0x1664u, 0xd3fdu, 0xf407u, 0x319eu, 0x3aacu,
        0xff35u, 0x2cc8u, 0xe951u, 0xe263u, 0x27fau, 0xad97u, 0x680eu, 0x633cu, 0xa6a5u, 0x7558u, 0xb0c1u,
        0xbbf3u, 0x7e6au, 0x5990u, 0x9c09u, 0x973bu, 0x52a2u, 0x815fu, 0x44c6u, 0x4ff4u, 0x8a6du, 0x5b2eu,
        0x9eb7u, 0x9585u, 0x501cu, 0x83e1u, 0x4678u, 0x4d4au, 0x88d3u, 0xaf29u, 0x6ab0u, 0x6182u, 0xa41bu,
        0x77e6u, 0xb27fu, 0xb94du, 0x7cd4u, 0xf6b9u, 0x3320u, 0x3812u, 0xfd8bu, 0x2e76u, 0xebefu, 0xe0ddu,
        0x2544u, 0x02beu, 0xc727u, 0xcc15u, 0x098cu, 0xda71u, 0x1fe8u, 0x14dau, 0xd143u, 0xf3c5u, 0x365cu,
        0x3d6eu, 0xf8f7u, 0x2b0au, 0xee93u, 0xe5a1u, 0x2038u, 0x07c2u, 0xc25bu, 0xc969u, 0x0cf0u, 0xdf0du,
        0x1a94u, 0x11a6u, 0xd43fu, 0x5e52u, 0x9bcbu, 0x90f9u, 0x5560u, 0x869du, 0x4304u, 0x4836u, 0x8dafu,
        0xaa55u, 0x6fccu, 0x64feu, 0xa167u, 0x729au, 0xb703u, 0xbc31u, 0x79a8u, 0xa8ebu, 0x6d72u, 0x6640u,
        0xa3d9u, 0x7024u, 0xb5bdu, 0xbe8fu, 0x7b16u, 0x5cecu, 0x9975u, 0x9247u, 0x57deu, 0x8423u, 0x41bau,
        0x4a88u, 0x8f11u, 0x057cu, 0xc0e5u, 0xcbd7u, 0x0e4eu, 0xddb3u, 0x182au, 0x1318u, 0xd681u, 0xf17bu,
        0x34e2u, 0x3fd0u, 0xfa49u, 0x29b4u, 0xec2du, 0xe71fu, 0x2286u, 0xa213u, 0x678au, 0x6cb8u, 0xa921u,
        0x7adcu, 0xbf45u, 0xb477u, 0x71eeu, 0x5614u, 0x938du, 0x98bfu, 0x5d26u, 0x8edbu, 0x4b42u, 0x4070u,
        0x85e9u, 0x0f84u, 0xca1du, 0xc12fu, 0x04b6u, 0xd74bu, 0x12d2u, 0x19e0u, 0xdc79u, 0xfb83u, 0x3e1au, 0x3528u,
        0xf0b1u, 0x234cu, 0xe6d5u, 0xede7u, 0x287eu, 0xf93du, 0x3ca4u, 0x3796u, 0xf20fu, 0x21f2u, 0xe46bu, 0xef59u,
        0x2ac0u, 0x0d3au, 0xc8a3u, 0xc391u, 0x0608u, 0xd5f5u, 0x106cu, 0x1b5eu, 0xdec7u, 0x54aau, 0x9133u, 0x9a01u,
        0x5f98u, 0x8c65u, 0x49fcu, 0x42ceu, 0x8757u, 0xa0adu, 0x6534u, 0x6e06u, 0xab9fu, 0x7862u, 0xbdfbu, 0xb6c9u,
        0x7350u, 0x51d6u, 0x944fu, 0x9f7du, 0x5ae4u, 0x8919u, 0x4c80u, 0x47b2u, 0x822bu, 0xa5d1u, 0x6048u, 0x6b7au,
        0xaee3u, 0x7d1eu, 0xb887u, 0xb3b5u, 0x762cu, 0xfc41u, 0x39d8u, 0x32eau, 0xf773u, 0x248eu, 0xe117u, 0xea25u,
        0x2fbcu, 0x0846u, 0xcddfu, 0xc6edu, 0x0374u, 0xd089u, 0x1510u, 0x1e22u, 0xdbbbu, 0x0af8u, 0xcf61u, 0xc453u,
        0x01cau, 0xd237u, 0x17aeu, 0x1c9cu, 0xd905u, 0xfeffu, 0x3b66u, 0x3054u, 0xf5cdu, 0x2630u, 0xe3a9u, 0xe89bu,
        0x2d02u, 0xa76fu, 0x62f6u, 0x69c4u, 0xac5du, 0x7fa0u, 0xba39u, 0xb10bu, 0x7492u, 0x5368u, 0x96f1u, 0x9dc3u,
        0x585au, 0x8ba7u, 0x4e3eu, 0x450cu, 0x8095u
        };

/* Pre-computed CRC10 Table */
static const uint16_t  Adbms6948_Crc10Table[256] =
{
    0x000, 0x08f, 0x11e, 0x191, 0x23c, 0x2b3, 0x322, 0x3ad, 0x0f7, 0x078, 0x1e9, 0x166, 0x2cb, 0x244, 0x3d5, 0x35a,
    0x1ee, 0x161, 0x0f0, 0x07f, 0x3d2, 0x35d, 0x2cc, 0x243, 0x119, 0x196, 0x007, 0x088, 0x325, 0x3aa, 0x23b, 0x2b4,
    0x3dc, 0x353, 0x2c2, 0x24d, 0x1e0, 0x16f, 0x0fe, 0x071, 0x32b, 0x3a4, 0x235, 0x2ba, 0x117, 0x198, 0x009, 0x086,
    0x232, 0x2bd, 0x32c, 0x3a3, 0x00e, 0x081, 0x110, 0x19f, 0x2c5, 0x24a, 0x3db, 0x354, 0x0f9, 0x076, 0x1e7, 0x168,
    0x337, 0x3b8, 0x229, 0x2a6, 0x10b, 0x184, 0x015, 0x09a, 0x3c0, 0x34f, 0x2de, 0x251, 0x1fc, 0x173, 0x0e2, 0x06d,
    0x2d9, 0x256, 0x3c7, 0x348, 0x0e5, 0x06a, 0x1fb, 0x174, 0x22e, 0x2a1, 0x330, 0x3bf, 0x012, 0x09d, 0x10c, 0x183,
    0x0eb, 0x064, 0x1f5, 0x17a, 0x2d7, 0x258, 0x3c9, 0x346, 0x01c, 0x093, 0x102, 0x18d, 0x220, 0x2af, 0x33e, 0x3b1,
    0x105, 0x18a, 0x01b, 0x094, 0x339, 0x3b6, 0x227, 0x2a8, 0x1f2, 0x17d, 0x0ec, 0x063, 0x3ce, 0x341, 0x2d0, 0x25f,
    0x2e1, 0x26e, 0x3ff, 0x370, 0x0dd, 0x052, 0x1c3, 0x14c, 0x216, 0x299, 0x308, 0x387, 0x02a, 0x0a5, 0x134, 0x1bb,
    0x30f, 0x380, 0x211, 0x29e, 0x133, 0x1bc, 0x02d, 0x0a2, 0x3f8, 0x377, 0x2e6, 0x269, 0x1c4, 0x14b, 0x0da, 0x055,
    0x13d, 0x1b2, 0x023, 0x0ac, 0x301, 0x38e, 0x21f, 0x290, 0x1ca, 0x145, 0x0d4, 0x05b, 0x3f6, 0x379, 0x2e8, 0x267,
    0x0d3, 0x05c, 0x1cd, 0x142, 0x2ef, 0x260, 0x3f1, 0x37e, 0x024, 0x0ab, 0x13a, 0x1b5, 0x218, 0x297, 0x306, 0x389,
    0x1d6, 0x159, 0x0c8, 0x047, 0x3ea, 0x365, 0x2f4, 0x27b, 0x121, 0x1ae, 0x03f, 0x0b0, 0x31d, 0x392, 0x203, 0x28c,
    0x038, 0x0b7, 0x126, 0x1a9, 0x204, 0x28b, 0x31a, 0x395, 0x0cf, 0x040, 0x1d1, 0x15e, 0x2f3, 0x27c, 0x3ed, 0x362,
    0x20a, 0x285, 0x314, 0x39b, 0x036, 0x0b9, 0x128, 0x1a7, 0x2fd, 0x272, 0x3e3, 0x36c, 0x0c1, 0x04e, 0x1df, 0x150,
    0x3e4, 0x36b, 0x2fa, 0x275, 0x1d8, 0x157, 0x0c6, 0x049, 0x313, 0x39c, 0x20d, 0x282, 0x12f, 0x1a0, 0x031, 0x0be
};
/* Const 16 section stop */
ADBMS6948_DRV_CONST_DATA_16_STOP


/*============= C O D E =============*/
/* Start of code section */
/* Code section start */
ADBMS6948_DRV_CODE_START

/*!
    @brief  This function is used to calculate the 15-bit PEC for a data buffer. It is used for
    command words.

    @param  [in]  pDataBuf  Buffer containing the data.

    @param  [in]  nLength  Length of the data buffer.

    @return  nFifteenBitPECVal  15-bit calculated PEC value.
 */
uint16_t Adbms6948_Pec15Calculate
(
    uint8_t 	*pDataBuf,
    uint8_t   	 nLength
)
{
    uint16_t  nRemainder, nTableAddr;
    uint8_t   nByteIndex;

    nRemainder = 16u;/* initialize the PEC */

    /* loops for each byte in data array */
    for (nByteIndex = 0u; nByteIndex < nLength; nByteIndex++)
    {
        /* calculate PEC table address */
        nTableAddr = (uint16_t)(((uint16_t)(nRemainder >> 7) ^ (uint8_t)pDataBuf[nByteIndex]) &
                (uint8_t)0xff);
        nRemainder = (uint16_t)((nRemainder << 8) ^ Adbms6948_Crc15Table[nTableAddr]);
    }
    /* The CRC15 has a 0 in the LSB so the remainder must be multiplied by 2 */
    return(nRemainder * 2u);
}

/*!
    @brief  This function is used to calculate the 10-bit PEC for a data buffer. It is used for
    data words.

    @param  [in]  pDataBuf  Buffer containing the data.

    @param  [in]  bIsRxCmd  Flag to indicate whether data words are part of receive command or not.

    @param  [in]  nLength  Length of the data buffer.

    @return  nTenBitPECVal  10-bit calculated PEC value.
*/
uint16_t Adbms6948_Pec10Calculate
(
uint8_t 	*pDataBuf,
boolean  	 bIsRxCmd,
uint8_t   	 nLength
)
{
    uint16_t   nRemainder = 16u;/* PEC_SEED */
    /* x10 + x7 + x3 + x2 + x + 1 <- the CRC10 polynomial 100 1000 1111 */
    uint16_t   nPolynomial = 0x8Fu;
    uint8_t   nByteIndex, nBitIndex;
    uint16_t   nTableAddr;

    for (nByteIndex = 0u; nByteIndex < nLength; ++nByteIndex)
    {
        /* calculate PEC table address */
        nTableAddr = (uint16_t)(((uint16_t)(nRemainder >> 2) ^ (uint8_t)pDataBuf[nByteIndex]) &
                (uint8_t)0xff);
        nRemainder = (uint16_t)(((uint16_t)(nRemainder << 8)) ^ Adbms6948_Crc10Table[nTableAddr]);
    }
    /* If array is from received buffer add command counter to crc calculation */
    if (bIsRxCmd == TRUE)
    {
        nRemainder ^= (uint16_t)(((uint16_t)pDataBuf[nLength] & (uint8_t)0xFC) << 2u);
    }
    /* Perform modulo-2 division, a bit at a time */
    for (nBitIndex = 6u; nBitIndex > 0u; --nBitIndex)
    {
        /* Try to divide the current data bit */
        if ((nRemainder & 0x200u) > 0u)
        {
            nRemainder = (uint16_t)((nRemainder << 1u));
            nRemainder = (uint16_t)(nRemainder ^ nPolynomial);
        }
        else
        {
            nRemainder = (uint16_t)((nRemainder << 1u));
        }
    }
    return ((uint16_t)(nRemainder & 0x3FFu));
}

/* End of code section */
/* Code section stop */
ADBMS6948_DRV_CODE_STOP

/*! @}*/ /* Adbms6948_Pec */

/*
*
* EOF
*
*/

